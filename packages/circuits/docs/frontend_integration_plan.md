# Frontend Integration Plan for zkAge Proof Verification

This guide explains how to make frontend integration seamless for verifying zero-knowledge proofs (ZKPs) generated by the zkAge pipeline. Share this document with frontend developers to ensure a smooth handoff and reliable in-browser verification.

---

## üì¶ Required Artifacts for Frontend Verification

After running the ZK pipeline, the following files are needed by the frontend:

- `proofs/carrental_all_proof.json` ‚Äî The ZK proof
- `proofs/carrental_all_public.json` ‚Äî The public inputs/signals
- `proofs/carrental_all_verification_key.json` ‚Äî The verification key

**Tip:** Place these files in a directory accessible to the frontend (e.g. `proofs/` or `verifier/static/`).

---

## üöö Automating Artifact Delivery

1. **Update your pipeline script** to copy or move the three files above to the shared directory after proof generation.
2. **Example Bash snippet:**
   ```bash
   mkdir -p proofs
   cp build/carrental_all_proof.json proofs/
   cp build/carrental_all_public.json proofs/
   cp build/carrental_all_verification_key.json proofs/
   ```
3. **Document the output paths** in your README for clarity.

---

## üß™ Testing & Validation During Integration

To ensure updates and changes do not break the pipeline or frontend integration, follow these testing steps at each stage:

### 1. Backend (Pipeline) Testing
- After any change to the circuit, scripts, or artifact locations, run the full pipeline:
  - Compile the circuit
  - Generate the witness, proof, and public signals
  - Verify the proof using SnarkJS CLI
- Confirm that all output files (`proof.json`, `public.json`, `verification_key.json`) are correctly generated and copied to the shared directory.
- Use a sample input and check for expected eligibility results in the public signals.

### 2. Frontend Testing
- After any change to file locations, formats, or frontend logic:
  - Load the new artifacts in the browser
  - Run the proof verification using the provided example code (see below)
  - Check that the frontend displays the correct verification result (valid/invalid)
- (Optional) Add a simple UI test button to trigger verification and display results.

### 3. Regression Testing
- Keep a set of valid sample artifacts in `proofs/` for quick regression checks after updates.
- If possible, automate pipeline and frontend tests (e.g., using npm scripts or CI workflows).

### 4. Troubleshooting
- If verification fails, double-check:
  - Input JSON format matches circuit expectations
  - Artifacts are not stale (clean/rebuild if needed)
  - Frontend is loading the correct files from the correct location

---

## üü¶ Minimal Frontend Verification Example (SnarkJS)

The frontend should:

1. Load the three files (using `fetch` or another method).
2. Use SnarkJS to verify the proof:

   ```js
   import { groth16 } from "snarkjs";

   const vkey = await fetch("proofs/carrental_all_verification_key.json").then(r => r.json());
   const proof = await fetch("proofs/carrental_all_proof.json").then(r => r.json());
   const publicSignals = await fetch("proofs/carrental_all_public.json").then(r => r.json());

   const res = await groth16.verify(vkey, publicSignals, proof);
   if (res === true) {
     console.log("Proof is valid!");
   } else {
     console.log("Proof is invalid!");
   }
   ```

---

## üìù Best Practices

- **Standardize file names and locations** so the frontend code does not need to change if the pipeline changes.
- **Document the expected format** of each file for the frontend team.
- **(Optional)** Provide a minimal `verifier/index.html` to demonstrate in-browser verification.

---

## üîó Handoff Checklist

- [ ] Proof, public, and verification key files are present in `proofs/`
- [ ] File formats and paths are documented
- [ ] Example verification code is provided to frontend
- [ ] Frontend can access and verify a sample proof

---

For questions or help, see the main README or contact the ZK pipeline maintainer.
